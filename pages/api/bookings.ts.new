import type { NextApiRequest, NextApiResponse } from 'next';
import { prisma } from '../../lib/prisma';

interface BookingData {
  name: string;
  email: string;
  date: string;
  time: string;
  guests: number;
}

interface DatabaseError extends Error {
  code?: string;
}

// Function to validate date format and value
const validateDate = (dateString: string): boolean => {
  const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!dateRegex.test(dateString)) {
    return false;
  }
  const date = new Date(dateString);
  return date instanceof Date && !isNaN(date.getTime());
};

// Function to validate time format (HH:MM in 24-hour format)
const validateTime = (timeString: string): boolean => {
  const timeRegex = /^([01]\d|2[0-3]):([0-5]\d)$/;
  return timeRegex.test(timeString);
};

// Function to validate email format
const validateEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { name, email, date, time, guests } = req.body as BookingData;

    // Input validation
    if (!name || !email || !date || !time || typeof guests !== 'number') {
      return res.status(400).json({
        error: "Missing required fields"
      });
    }

    if (!validateEmail(email)) {
      return res.status(400).json({
        error: "Invalid email format"
      });
    }

    if (!validateDate(date)) {
      return res.status(400).json({
        error: "Invalid date format. Use YYYY-MM-DD"
      });
    }

    if (!validateTime(time)) {
      return res.status(400).json({
        error: "Invalid time format. Use HH:MM (24-hour)"
      });
    }

    if (guests < 1 || guests > 20) {
      return res.status(400).json({
        error: "Invalid number of guests (1-20)"
      });
    }

    // Create booking in database
    const booking = await prisma.booking.create({
      data: {
        name,
        email,
        date: new Date(date),
        time,
        guests
      }
    });

    return res.status(201).json({
      success: true,
      message: 'Booking created successfully',
      booking: {
        id: booking.id,
        date: booking.date,
        time: booking.time,
        guests: booking.guests
      }
    });

  } catch (error) {
    console.error("Booking API error:", error);

    let statusCode = 500;
    const dbError = error as DatabaseError;
    let responseMessage = "Internal server error";

    if (error instanceof Error) {
      switch (dbError.code) {
        case "P2002": // Prisma unique constraint violation
          statusCode = 409;
          responseMessage = "Booking conflict - this time slot may already be taken";
          break;
        case "P2003": // Foreign key constraint failed
          statusCode = 400;
          responseMessage = "Invalid reference data";
          break;
        case "P2025": // Record not found
          statusCode = 404;
          responseMessage = "Record not found";
          break;
        case "23505": // PostgreSQL unique violation
          statusCode = 409;
          responseMessage = "Booking conflict - this time slot may already be taken";
          break;
        case "23502": // PostgreSQL not null violation
          statusCode = 400;
          responseMessage = "Missing required database field";
          break;
        case "22008":
        case "22007": // PostgreSQL datetime format error
          statusCode = 400;
          responseMessage = "Invalid date or time format";
          break;
        case "ECONNREFUSED":
        case "ETIMEDOUT":
          statusCode = 503;
          responseMessage = "Database connection failed";
          break;
        default:
          if (dbError.message?.includes("Prisma")) {
            statusCode = 500;
            responseMessage = "Database operation failed";
          } else {
            responseMessage = error.message;
          }
      }
    }

    return res.status(statusCode).json({
      error: responseMessage,
      details: process.env.NODE_ENV === "development" && error instanceof Error ? error.message : undefined
    });
  }
}
